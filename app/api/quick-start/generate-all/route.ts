import { NextRequest, NextResponse } from "next/server";
import { createClient } from "@/utils/supabase/server";
import { createOpenRouter } from "@openrouter/ai-sdk-provider";
import { z } from "zod";

export const runtime = "edge";
export const maxDuration = 60;

// Zod schemas for type-safe LLM responses
const PanelSchema = z.object({
  panelNumber: z.number(),
  prompt: z.string(),
  shotType: z.enum([
    "wide",
    "medium",
    "close-up",
    "extreme-close-up",
    "establishing",
  ]),
  characters: z.array(z.string()),
  dialogue: z.string(),
  narration: z.string(),
});

const PageSchema = z.object({
  pageNumber: z.number(),
  panels: z.array(PanelSchema),
});

const openrouter = createOpenRouter({
  apiKey: process.env.OPENAI_API_KEY!,
});

export async function POST(request: NextRequest) {
  try {
    const supabase = await createClient();

    // Check authentication (Sub-task 7.9 - Error handling)
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json(
        { error: "Unauthorized. Please log in to continue." },
        { status: 401 }
      );
    }

    // Sub-task 7.2: Accept projectId as parameter
    const body = await request.json();
    const { projectId } = body;

    if (!projectId) {
      return NextResponse.json(
        { error: "Missing required field: projectId" },
        { status: 400 }
      );
    }

    // Sub-task 7.3: Fetch project and verify it's in preview stage
    const { data: project, error: projectError } = await supabase
      .from("projects")
      .select("*")
      .eq("id", projectId)
      .eq("user_id", user.id)
      .single();

    if (projectError || !project) {
      console.error("Failed to fetch project:", projectError);
      return NextResponse.json(
        { error: "Project not found or access denied" },
        { status: 404 }
      );
    }

    // Verify project is in preview stage
    if (project.generation_stage !== "preview") {
      return NextResponse.json(
        {
          error: `Project is not in preview stage. Current stage: ${project.generation_stage}`,
        },
        { status: 400 }
      );
    }

    // Verify project is preview_only
    if (!project.preview_only) {
      return NextResponse.json(
        { error: "Project is already fully generated" },
        { status: 400 }
      );
    }

    // Sub-task 7.4: Calculate remaining pages to generate (total_pages - 4)
    const totalPages = project.total_pages || 0;
    const previewPageCount = 4;
    const remainingPages = totalPages - previewPageCount;

    if (remainingPages <= 0) {
      return NextResponse.json(
        { error: "No remaining pages to generate" },
        { status: 400 }
      );
    }

    // Fetch existing pages to determine which pages need to be created
    const { data: existingPages, error: pagesError } = await supabase
      .from("pages")
      .select("page_number")
      .eq("project_id", projectId)
      .order("page_number", { ascending: true });

    if (pagesError) {
      console.error("Failed to fetch existing pages:", pagesError);
      return NextResponse.json(
        { error: "Failed to fetch existing pages" },
        { status: 500 }
      );
    }

    const existingPageNumbers = new Set(
      existingPages?.map((p) => p.page_number) || []
    );

    // Fetch characters for this project
    const { data: characters, error: charactersError } = await supabase
      .from("characters")
      .select("*")
      .eq("project_id", projectId);

    if (charactersError) {
      console.error("Failed to fetch characters:", charactersError);
      return NextResponse.json(
        { error: "Failed to fetch characters" },
        { status: 500 }
      );
    }

    const characterIds: Record<string, string> = {};
    const characterNames: string[] = [];
    
    (characters || []).forEach((char) => {
      characterIds[char.name] = char.id;
      characterNames.push(char.name);
    });

    // Sub-task 7.5: Generate remaining pages asynchronously
    // We'll create the page structure now, and images will be generated by the client
    const pagesToGenerate: number[] = [];
    for (let i = previewPageCount + 1; i <= totalPages; i++) {
      if (!existingPageNumbers.has(i)) {
        pagesToGenerate.push(i);
      }
    }

    if (pagesToGenerate.length === 0) {
      // All pages already exist, just update the flags
      await supabase
        .from("projects")
        .update({
          preview_only: false,
          generation_stage: "complete",
        })
        .eq("id", projectId);

      return NextResponse.json({
        success: true,
        message: "All pages already generated",
        pagesGenerated: 0,
      });
    }

    // Generate page structure for remaining pages
    try {
      for (const pageNumber of pagesToGenerate) {
        // Create page
        const { data: page, error: pageError } = await supabase
          .from("pages")
          .insert({
            project_id: projectId,
            page_number: pageNumber,
            layout_data: {
              template: "grid",
              panels: [],
            },
          })
          .select()
          .single();

        if (pageError || !page) {
          console.error("Failed to create page:", pageError);
          throw new Error(`Failed to create page ${pageNumber}`);
        }

        // Generate 2-4 panels per page (vary for pacing)
        const panelCount = 2 + Math.floor(Math.random() * 3); // 2-4 panels
        const panelsToInsert = [];

        for (let panelIndex = 0; panelIndex < panelCount; panelIndex++) {
          // Calculate panel position in a grid layout
          const panelsPerRow = 2;
          const panelWidth = 400;
          const panelHeight = 300;
          const col = panelIndex % panelsPerRow;
          const row = Math.floor(panelIndex / panelsPerRow);

          // Generate a simple prompt for the panel
          // In a real implementation, this would use AI to generate contextual prompts
          const randomCharacters = characterNames
            .sort(() => Math.random() - 0.5)
            .slice(0, Math.floor(Math.random() * 2) + 1);

          const charHandles = randomCharacters.map(
            (name) => `@${name.toLowerCase().replace(/\s+/g, "")}`
          );

          const charRefs = randomCharacters
            .map((name) => characterIds[name])
            .filter(Boolean);

          const shotTypes = [
            "wide",
            "medium",
            "close-up",
            "extreme-close-up",
            "establishing",
          ];
          const shotType =
            shotTypes[Math.floor(Math.random() * shotTypes.length)];

          panelsToInsert.push({
            page_id: page.id,
            panel_index: panelIndex,
            x: col * (panelWidth + 20),
            y: row * (panelHeight + 20),
            width: panelWidth,
            height: panelHeight,
            prompt: `${randomCharacters.join(" and ")} in a ${shotType} shot, manga style`,
            character_refs: charRefs,
            character_handles: charHandles,
            style_locks: [],
            bubbles: [],
          });
        }

        const { error: panelsError } = await supabase
          .from("panels")
          .insert(panelsToInsert);

        if (panelsError) {
          console.error("Failed to create panels:", panelsError);
          throw new Error(`Failed to create panels for page ${pageNumber}`);
        }
      }

      // Sub-task 7.6: Update preview_only: false
      // Sub-task 7.7: Update generation_stage: 'complete'
      const { error: updateError } = await supabase
        .from("projects")
        .update({
          preview_only: false,
          generation_stage: "complete",
          generation_progress: {
            script: 100,
            characters: 100,
            storyboard: 100,
            preview: 100,
          },
        })
        .eq("id", projectId);

      if (updateError) {
        console.error("Failed to update project:", updateError);
        throw new Error("Failed to update project status");
      }

      // Sub-task 7.8: Return success response
      return NextResponse.json({
        success: true,
        message: "All pages generated successfully",
        pagesGenerated: pagesToGenerate.length,
        totalPages,
      });
    } catch (structureError) {
      console.error("Structure generation error:", structureError);
      return NextResponse.json(
        { error: "Failed to generate remaining pages" },
        { status: 500 }
      );
    }
  } catch (error) {
    // Sub-task 7.9: Add error handling
    console.error("Generate-all error:", error);

    if (error instanceof SyntaxError) {
      return NextResponse.json(
        { error: "Invalid request format" },
        { status: 400 }
      );
    }

    return NextResponse.json(
      {
        error: "An unexpected error occurred. Please try again.",
        details: error instanceof Error ? error.message : "Unknown error",
      },
      { status: 500 }
    );
  }
}
